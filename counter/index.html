<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Panel Mask – Fixed & Sensitive Curves</title>
<style>
body{margin:0;font-family:sans-serif;background:#f2f2f2}
.controls{text-align:center;padding:8px}
canvas{display:block;margin:auto;max-width:95vw;background:#666;touch-action:none}
button,input,textarea{margin:4px}
.panel-ui{background:#fff;border:1px solid #ccc;margin:6px;padding:6px}
.hidden{display:none}
</style>
</head>
<body>

<div class="controls">
<input type="file" id="upload"><br>

横 <input type="number" id="cols" value="4" min="1">
縦 <input type="number" id="rows" value="4" min="1">
合計 <span id="total">16</span><br>

<button id="panelBuild">パネル生成</button>
<button id="panelEdit">パネル編集</button>
<button id="mergeBtn">パネル合体</button><br>

パネル色 <input type="color" id="panelColor" value="#000000">
枠線色 <input type="color" id="lineColor" value="#00ffff">
</div>

<canvas id="canvas"></canvas>
<div id="panelTexts"></div>

<script>
/* ===== 基本 ===== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const upload = document.getElementById("upload");
const colsInput = document.getElementById("cols");
const rowsInput = document.getElementById("rows");
const total = document.getElementById("total");
const panelBuild = document.getElementById("panelBuild");
const panelEdit = document.getElementById("panelEdit");
const mergeBtn = document.getElementById("mergeBtn");
const panelColor = document.getElementById("panelColor");
const lineColor = document.getElementById("lineColor");
const panelTexts = document.getElementById("panelTexts");

let img = new Image();
let cols = 4, rows = 4;
let mode = "edit";
let mergeMode = false;
let selected = new Set();

let hLines = [], vLines = [];
let panelGroup = [], groupVisible = {};
let panelData = [];
let panelPaths = {};

let drag = null;

const MAX = 900;
const HIT = 14;
const CURVE_SENS = 1.8; // ★ 感度UP

/* ===== 即時再生成 ===== */
colsInput.oninput = rowsInput.oninput = rebuild;

/* ===== 画像 ===== */
upload.onchange = e => {
  const r = new FileReader();
  r.onload = ev => img.src = ev.target.result;
  r.readAsDataURL(e.target.files[0]);
};
img.onload = () => {
  const s = Math.min(MAX / img.width, MAX / img.height);
  canvas.width = img.width * s;
  canvas.height = img.height * s;
  rebuild();
};

/* ===== 再生成 ===== */
function rebuild(){
  cols = +colsInput.value;
  rows = +rowsInput.value;
  total.textContent = cols * rows;

  hLines=[]; vLines=[];
  panelGroup=[]; groupVisible={};
  panelData=[]; panelPaths={};
  panelTexts.innerHTML="";
  mergeMode=false; selected.clear();
  mode="edit";

  for(let y=0;y<=rows;y++){
    hLines[y]=[];
    for(let x=0;x<cols;x++) hLines[y][x]={dy:0};
  }
  for(let x=0;x<=cols;x++){
    vLines[x]=[];
    for(let y=0;y<rows;y++) vLines[x][y]={dx:0};
  }

  for(let i=0;i<cols*rows;i++){
    panelGroup[i]=i;
    groupVisible[i]=true;
    panelData[i]={name:"",cond:""};
  }
  draw();
}

/* ===== 曲線パス（単体） ===== */
function curvedPath(x,y){
  const w=canvas.width/cols,h=canvas.height/rows;
  const x0=x*w,y0=y*h,x1=x0+w,y1=y0+h;
  const p=new Path2D();
  p.moveTo(x0,y0);
  p.quadraticCurveTo(x0+w/2,y0+hLines[y][x].dy,x1,y0);
  p.quadraticCurveTo(x1+vLines[x+1][y].dx,y0+h/2,x1,y1);
  p.quadraticCurveTo(x0+w/2,y1+hLines[y+1][x].dy,x0,y1);
  p.quadraticCurveTo(x0+vLines[x][y].dx,y0+h/2,x0,y0);
  p.closePath();
  return p;
}

/* ===== 描画 ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width,canvas.height);

  for(let i=0;i<cols*rows;i++){
    const path = curvedPath(i%cols, Math.floor(i/cols));
    ctx.fillStyle = panelColor.value;
    ctx.fill(path);
    ctx.strokeStyle = lineColor.value;
    ctx.stroke(path);
  }
}

/* ===== 曲線編集 ===== */
canvas.onpointerdown = e => {
  if(mode!=="edit") return;
  const r = canvas.getBoundingClientRect();
  const px = (e.clientX-r.left)*(canvas.width/r.width);
  const py = (e.clientY-r.top)*(canvas.height/r.height);
  const w=canvas.width/cols,h=canvas.height/rows;
  const x=Math.floor(px/w), y=Math.floor(py/h);

  if(Math.abs(py-y*h)<HIT) drag={t:"h",x,y};
  else if(Math.abs(px-x*w)<HIT) drag={t:"v",x,y};
};

canvas.onpointermove = e => {
  if(!drag) return;
  const r = canvas.getBoundingClientRect();
  const px = (e.clientX-r.left)*(canvas.width/r.width);
  const py = (e.clientY-r.top)*(canvas.height/r.height);

  if(drag.t==="h"){
    const base = drag.y*(canvas.height/rows);
    hLines[drag.y][drag.x].dy = (py-base)*CURVE_SENS;
  }else{
    const base = drag.x*(canvas.width/cols);
    vLines[drag.x][drag.y].dx = (px-base)*CURVE_SENS;
  }
  draw();
};
canvas.onpointerup = ()=> drag=null;
</script>
</body>
</html>
