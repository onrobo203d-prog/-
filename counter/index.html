<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Panel Reveal</title>
<style>
body{
  margin:0;
  font-family:sans-serif;
  background:#f5f5f5;
  text-align:center;
}

.controls{
  margin:15px;
}

#canvasArea{
  display:flex;
  justify-content:center;
  align-items:center;
  margin:60px 0;
}

canvas{
  background:#999;
  box-shadow:0 0 10px rgba(0,0,0,0.2);
  touch-action:none;
}

button{
  margin:5px;
  padding:6px 12px;
}

input[type=color]{
  height:30px;
}
</style>
</head>
<body>

<h2>Panel Reveal Builder</h2>

<div class="controls">
<input type="file" id="upload">
壁色 <input type="color" id="wallColor" value="#000000">
線太さ <input type="range" id="lineWidth" min="2" max="30" value="8">
<button id="splitBtn">パネル分割</button>
<button id="resetBtn">リセット</button>
</div>

<div class="controls">
<button id="modeBtn">編集</button>
<button id="previewBtn">プレビュー出力</button>
</div>

<div id="canvasArea">
<canvas id="canvas"></canvas>
</div>

<script>
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

let image=new Image();
let lines=[];
let panels=[];
let drawing=false;
let mode="edit";

let canvasW=0;
let canvasH=0;

const MAX_EDIT_SIZE=800;

document.getElementById("upload").onchange=e=>{
 const file=e.target.files[0];
 const reader=new FileReader();
 reader.onload=ev=>{
  image.src=ev.target.result;
 };
 reader.readAsDataURL(file);
};

image.onload=()=>{
 const ratio=Math.min(MAX_EDIT_SIZE/image.width,MAX_EDIT_SIZE/image.height);
 canvasW=image.width*ratio;
 canvasH=image.height*ratio;
 canvas.width=canvasW;
 canvas.height=canvasH;
 lines=[];
 panels=[];
 drawAll();
};

function drawAll(){
 ctx.clearRect(0,0,canvasW,canvasH);
 ctx.drawImage(image,0,0,canvasW,canvasH);

 lines.forEach(line=>{
  ctx.strokeStyle=line.color;
  ctx.lineWidth=line.width;
  ctx.beginPath();
  ctx.moveTo(line.points[0].x, line.points[0].y);
  for(let i=1;i<line.points.length;i++){
   ctx.lineTo(line.points[i].x,line.points[i].y);
  }
  ctx.stroke();
 });

 panels.forEach(p=>{
  if(mode==="edit" || !p.unlocked){
   ctx.fillStyle=p.color;
   ctx.fill(p.path);
  }
 });
}

canvas.addEventListener("pointerdown",e=>{
 if(mode!=="edit")return;
 drawing=true;
 const pos=getPos(e);
 lines.push({
  color:document.getElementById("wallColor").value,
  width:document.getElementById("lineWidth").value,
  points:[pos]
 });
});

canvas.addEventListener("pointermove",e=>{
 if(!drawing)return;
 const pos=getPos(e);
 lines[lines.length-1].points.push(pos);
 drawAll();
});

canvas.addEventListener("pointerup",()=>drawing=false);

canvas.addEventListener("click",e=>{
 if(mode!=="play")return;
 const pos=getPos(e);
 panels.forEach(p=>{
  if(ctx.isPointInPath(p.path,pos.x,pos.y)){
   p.unlocked=!p.unlocked;
  }
 });
 drawAll();
});

function getPos(e){
 const rect=canvas.getBoundingClientRect();
 return{
  x:(e.clientX-rect.left),
  y:(e.clientY-rect.top)
 };
}

document.getElementById("splitBtn").onclick=()=>{
 if(!image.src)return;

 const imgData=ctx.getImageData(0,0,canvasW,canvasH);
 const data=imgData.data;
 const visited=new Uint8Array(canvasW*canvasH);
 panels=[];

 function isWall(x,y){
  if(x<=0||y<=0||x>=canvasW-1||y>=canvasH-1)return true;
  const i=(Math.floor(y)*canvasW+Math.floor(x))*4;
  const r=data[i],g=data[i+1],b=data[i+2];
  const wc=hexToRgb(document.getElementById("wallColor").value);
  return Math.abs(r-wc.r)<8 &&
         Math.abs(g-wc.g)<8 &&
         Math.abs(b-wc.b)<8;
 }

 for(let y=0;y<canvasH;y++){
  for(let x=0;x<canvasW;x++){
   const idx=y*canvasW+x;
   if(visited[idx]||isWall(x,y))continue;

   const stack=[[x,y]];
   const points=[];
   visited[idx]=1;

   while(stack.length){
    const [sx,sy]=stack.pop();
    points.push([sx,sy]);

    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
     const nx=sx+dx,ny=sy+dy;
     const nidx=ny*canvasW+nx;
     if(nx>=0&&ny>=0&&nx<canvasW&&ny<canvasH&&!visited[nidx]&&!isWall(nx,ny)){
      visited[nidx]=1;
      stack.push([nx,ny]);
     }
    });
   }

   const path=new Path2D();
   points.forEach(([px,py])=>{
    path.rect(px,py,1,1);
   });

   panels.push({
    path,
    color:"#ffffff",
    unlocked:false
   });
  }
 }

 drawAll();
};

document.getElementById("resetBtn").onclick=()=>{
 lines=[];
 panels=[];
 drawAll();
};

document.getElementById("modeBtn").onclick=function(){
 if(mode==="edit"){
  mode="play";
  this.textContent="編集";
 }else{
  mode="edit";
  this.textContent="保存";
 }
 drawAll();
};

document.getElementById("previewBtn").onclick=()=>{
 if(!image.src)return;

 const max=1080;
 const ratio=Math.min(max/image.width,max/image.height);
 const outW=image.width*ratio;
 const outH=image.height*ratio;

 const out=document.createElement("canvas");
 out.width=outW;
 out.height=outH;
 const octx=out.getContext("2d");

 octx.drawImage(image,0,0,outW,outH);

 panels.forEach(p=>{
  if(!p.unlocked){
   octx.fillStyle=p.color;
   const scaleX=outW/canvasW;
   const scaleY=outH/canvasH;
   octx.save();
   octx.scale(scaleX,scaleY);
   octx.fill(p.path);
   octx.restore();
  }
 });

 const win=window.open();
 win.document.body.appendChild(out);
};

function hexToRgb(hex){
 const bigint=parseInt(hex.slice(1),16);
 return{
  r:(bigint>>16)&255,
  g:(bigint>>8)&255,
  b:bigint&255
 };
}
</script>

</body>
</html>
