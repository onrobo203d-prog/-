<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Panel Mask Controller FIX</title>
<style>
body{margin:0;font-family:sans-serif;background:#f2f2f2}
.controls{text-align:center;padding:8px}
canvas{display:block;margin:auto;max-width:95vw;background:#aaa;touch-action:none}
button,input,textarea{margin:4px}
.panel-ui{background:#fff;border:1px solid #ccc;margin:6px;padding:6px}
.panel-ui input,.panel-ui textarea{width:95%}
</style>
</head>
<body>

<div class="controls">
<input type="file" id="upload"><br>

横 <input type="number" id="cols" value="4" min="1">
縦 <input type="number" id="rows" value="4" min="1">
合計 <span id="total">16</span><br>

<button id="panelBuild">パネル生成</button>
<button id="panelEdit">パネル編集</button>
<button id="undoBtn">↩ 戻る</button>
<button id="previewBtn">進捗プレビュー</button><br>

パネル色 <input type="color" id="panelColor" value="#000000">
枠線色 <input type="color" id="lineColor" value="#00ffff">
枠線表示 <input type="checkbox" id="lineVisible" checked>
</div>

<canvas id="canvas"></canvas>
<div id="panelTexts"></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let img=new Image();
let cols=4, rows=4;
let mode="edit";
let panels=[];
let fixedPaths=[];   // ★再生用確定Path
let undoStack=[];
let drag=null;

const MAX=900;
const HIT=12;

/* ---------- 入力 ---------- */
colsInput.oninput = rowsInput.oninput = ()=>{
  total.textContent = colsInput.value * rowsInput.value;
};

upload.onchange=e=>{
  const r=new FileReader();
  r.onload=ev=>img.src=ev.target.result;
  r.readAsDataURL(e.target.files[0]);
};

img.onload=()=>{
  const r=Math.min(MAX/img.width,MAX/img.height);
  canvas.width=img.width*r;
  canvas.height=img.height*r;
  initGrid();
};

/* ---------- 初期化 ---------- */
function initGrid(){
  cols=+colsInput.value;
  rows=+rowsInput.value;
  total.textContent=cols*rows;
  panels=[];
  fixedPaths=[];
  undoStack=[];
  panelTexts.innerHTML="";

  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      panels.push({
        x,y,visible:true,
        name:"",condition:"",textColor:"#fff",
        edges:{
          top:{dx:0,dy:0},
          right:{dx:0,dy:0},
          bottom:{dx:0,dy:0},
          left:{dx:0,dy:0}
        }
      });
      createTextUI(x,y);
    }
  }
  draw();
}

/* ---------- パネル生成（再生突入） ---------- */
panelBuild.onclick=()=>{
  mode="play";
  colsInput.disabled=true;
  rowsInput.disabled=true;
  fixedPaths = panels.map(p=>getPanelPath(p)); // ★ここで確定
  draw();
};

/* ---------- パネル編集に戻る ---------- */
panelEdit.onclick=()=>{
  mode="edit";
  colsInput.disabled=false;
  rowsInput.disabled=false;
  panels.forEach(p=>p.visible=true);
  undoStack=[];
  fixedPaths=[];
  draw();
};

/* ---------- UI ---------- */
function createTextUI(x,y){
  const i=y*cols+x;
  const d=document.createElement("div");
  d.className="panel-ui";
  d.innerHTML=`
  <b>パネル ${i+1}</b><br>
  名称<br><input data-i="${i}" data-t="name"><br>
  条件<br><textarea rows="2" data-i="${i}" data-t="cond"></textarea><br>
  文字色 <input type="color" value="#ffffff" data-i="${i}" data-t="color">
  `;
  d.oninput=e=>{
    const p=panels[e.target.dataset.i];
    if(e.target.dataset.t==="name") p.name=e.target.value;
    if(e.target.dataset.t==="cond") p.condition=e.target.value;
    if(e.target.dataset.t==="color") p.textColor=e.target.value;
    draw();
  };
  panelTexts.appendChild(d);
}

/* ---------- 描画 ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(img.src) ctx.drawImage(img,0,0,canvas.width,canvas.height);

  panels.forEach((p,i)=>{
    if(!p.visible) return;
    const path = (mode==="play" && fixedPaths[i]) ? fixedPaths[i] : getPanelPath(p);
    ctx.fillStyle=panelColor.value;
    ctx.fill(path);
    if(lineVisible.checked){
      ctx.strokeStyle=lineColor.value;
      ctx.stroke(path);
    }
    drawText(p);
  });
}

function getPanelPath(p){
  const w=canvas.width/cols;
  const h=canvas.height/rows;
  const x0=p.x*w, y0=p.y*h;
  const x1=x0+w, y1=y0+h;
  const path=new Path2D();

  path.moveTo(x0,y0);
  path.quadraticCurveTo(x0+w/2+p.edges.top.dx,y0+p.edges.top.dy,x1,y0);
  path.quadraticCurveTo(x1+p.edges.right.dx,y0+h/2+p.edges.right.dy,x1,y1);
  path.quadraticCurveTo(x0+w/2+p.edges.bottom.dx,y1+p.edges.bottom.dy,x0,y1);
  path.quadraticCurveTo(x0+p.edges.left.dx,y0+h/2+p.edges.left.dy,x0,y0);
  path.closePath();
  return path;
}

function drawText(p){
  const w=canvas.width/cols;
  const h=canvas.height/rows;
  ctx.fillStyle=p.textColor;
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.font="14px sans-serif";
  const cx=p.x*w+w/2;
  const cy=p.y*h+h/2;
  if(p.name) ctx.fillText(p.name,cx,cy-8);
  if(p.condition) ctx.fillText(p.condition,cx,cy+8);
}

/* ---------- 編集：辺ドラッグ ---------- */
canvas.onpointerdown=e=>{
  if(mode!=="edit") return;
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(canvas.width/r.width);
  const y=(e.clientY-r.top)*(canvas.height/r.height);

  panels.forEach(p=>{
    const w=canvas.width/cols;
    const h=canvas.height/rows;
    const x0=p.x*w, y0=p.y*h;
    const x1=x0+w, y1=y0+h;
    if(Math.abs(y-y0)<HIT) drag={p,edge:"top"};
    else if(Math.abs(y-y1)<HIT) drag={p,edge:"bottom"};
    else if(Math.abs(x-x0)<HIT) drag={p,edge:"left"};
    else if(Math.abs(x-x1)<HIT) drag={p,edge:"right"};
  });
};

canvas.onpointermove=e=>{
  if(!drag) return;
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(canvas.width/r.width);
  const y=(e.clientY-r.top)*(canvas.height/r.height);
  const p=drag.p;
  const w=canvas.width/cols;
  const h=canvas.height/rows;
  p.edges[drag.edge].dx=Math.max(-w/2,Math.min(w/2,x-(p.x*w+w/2)));
  p.edges[drag.edge].dy=Math.max(-h/2,Math.min(h/2,y-(p.y*h+h/2)));
  draw();
};
canvas.onpointerup=()=>drag=null;

/* ---------- 再生：判定 ---------- */
canvas.onclick=e=>{
  if(mode!=="play") return;
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(canvas.width/r.width);
  const y=(e.clientY-r.top)*(canvas.height/r.height);

  fixedPaths.forEach((path,i)=>{
    if(!panels[i].visible) return;
    if(ctx.isPointInPath(path,x,y)){
      panels[i].visible=false;
      undoStack.push(i);
      draw();
    }
  });
};

undoBtn.onclick=()=>{
  const i=undoStack.pop();
  if(i!==undefined){
    panels[i].visible=true;
    draw();
  }
};

/* ---------- プレビュー ---------- */
previewBtn.onclick=()=>{
  const c=document.createElement("canvas");
  c.width=canvas.width;
  c.height=canvas.height;
  const o=c.getContext("2d");
  o.drawImage(img,0,0,c.width,c.height);
  fixedPaths.forEach((p,i)=>{
    if(panels[i].visible){
      o.fillStyle=panelColor.value;
      o.fill(p);
    }
  });
  const w=window.open();
  w.document.body.appendChild(c);
};
</script>

</body>
</html>
