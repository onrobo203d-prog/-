<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Panel Mask – Merge Complete</title>
<style>
body{margin:0;font-family:sans-serif;background:#f2f2f2}
.controls{text-align:center;padding:8px}
canvas{display:block;margin:auto;max-width:95vw;background:#777;touch-action:none}
button,input,textarea{margin:4px}
.panel-ui{background:#fff;border:1px solid #ccc;margin:6px;padding:6px}
.hidden{display:none}
#previewWrap{
  position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:none;align-items:center;justify-content:center;
}
</style>
</head>
<body>

<div class="controls">
<input type="file" id="upload"><br>

横 <input type="number" id="cols" value="4" min="1">
縦 <input type="number" id="rows" value="4" min="1">
合計 <span id="total">16</span><br>

<button id="panelBuild">パネル生成</button>
<button id="panelEdit">パネル編集</button>
<button id="mergeBtn">パネル合体</button>
<button id="previewBtn">進捗プレビュー</button><br>

パネル色 <input type="color" id="panelColor" value="#000000">
枠線色 <input type="color" id="lineColor" value="#00ffff">
</div>

<canvas id="canvas"></canvas>
<div id="panelTexts"></div>

<div id="previewWrap" onclick="this.style.display='none'">
  <canvas id="previewCanvas"></canvas>
</div>

<script>
/* ===== 共通 ===== */
const $=id=>document.getElementById(id);
const canvas=$("canvas"),ctx=canvas.getContext("2d");
const previewCanvas=$("previewCanvas"),pctx=previewCanvas.getContext("2d");

let img=new Image();
let cols=4,rows=4,mode="edit";
let hLines=[],vLines=[];
let panelGroup=[],groupData={},groupVisible={};
let panelPaths={};
let mergeMode=false,selected=new Set();
let drag=null;

const MAX=900,HIT=14;

/* ===== 即再生成 ===== */
colsInput.oninput=rowsInput.oninput=()=>rebuild();

/* ===== 画像 ===== */
upload.onchange=e=>{
  const r=new FileReader();
  r.onload=ev=>img.src=ev.target.result;
  r.readAsDataURL(e.target.files[0]);
};
img.onload=()=>{
  const s=Math.min(MAX/img.width,MAX/img.height);
  canvas.width=previewCanvas.width=img.width*s;
  canvas.height=previewCanvas.height=img.height*s;
  rebuild();
};

/* ===== 再生成 ===== */
function rebuild(){
  cols=+colsInput.value;rows=+rowsInput.value;
  total.textContent=cols*rows;
  hLines=[];vLines=[];
  panelGroup=[];groupData={};groupVisible={};
  panelPaths={};
  panelTexts.innerHTML="";
  mergeMode=false;selected.clear();
  mergeBtn.textContent="パネル合体";
  mode="edit";

  for(let y=0;y<=rows;y++){
    hLines[y]=[];
    for(let x=0;x<cols;x++) hLines[y][x]={dy:0};
  }
  for(let x=0;x<=cols;x++){
    vLines[x]=[];
    for(let y=0;y<rows;y++) vLines[x][y]={dx:0};
  }

  for(let i=0;i<cols*rows;i++){
    panelGroup[i]=i;
    groupVisible[i]=true;
    groupData[i]={name:"",cond:"",color:"#fff",size:16};
    createTextUI(i);
  }
  draw();
}

/* ===== テキストUI（group単位） ===== */
function createTextUI(g){
  const d=document.createElement("div");
  d.className="panel-ui";
  d.id="ui-"+g;
  d.innerHTML=`
<b>パネル ${g+1}</b><br>
<input placeholder="名称"><br>
<textarea rows="2" placeholder="条件"></textarea><br>
文字サイズ <input type="range" min="8" max="48" value="16">
`;
  const inputs=d.querySelectorAll("input,textarea");
  inputs[0].oninput=e=>{groupData[g].name=e.target.value;draw();}
  inputs[1].oninput=e=>{groupData[g].cond=e.target.value;draw();}
  inputs[2].oninput=e=>{groupData[g].size=+e.target.value;draw();}
  panelTexts.appendChild(d);
}

/* ===== 合体 ===== */
mergeBtn.onclick=()=>{
  if(mode!=="edit") return;
  if(!mergeMode){
    mergeMode=true;selected.clear();
    mergeBtn.textContent="合体実行";
  }else{
    const ids=[...selected];
    if(ids.length>1){
      const g=panelGroup[ids[0]];
      ids.forEach(i=>{
        const old=panelGroup[i];
        panelGroup[i]=g;
        if(old!==g) document.getElementById("ui-"+old)?.classList.add("hidden");
      });
    }
    mergeMode=false;selected.clear();
    mergeBtn.textContent="パネル合体";
  }
  draw();
};

/* ===== 曲線Path ===== */
function curvedPath(x,y){
  const w=canvas.width/cols,h=canvas.height/rows;
  const x0=x*w,y0=y*h,x1=x0+w,y1=y0+h;
  const p=new Path2D();
  p.moveTo(x0,y0);
  p.quadraticCurveTo(x0+w/2,y0+hLines[y][x].dy,x1,y0);
  p.quadraticCurveTo(x1+vLines[x+1][y].dx,y0+h/2,x1,y1);
  p.quadraticCurveTo(x0+w/2,y1+hLines[y+1][x].dy,x0,y1);
  p.quadraticCurveTo(x0+vLines[x][y].dx,y0+h/2,x0,y0);
  p.closePath();
  return p;
}

/* ===== groupPath ===== */
function buildPaths(){
  panelPaths={};
  for(let i=0;i<panelGroup.length;i++){
    const g=panelGroup[i];
    if(panelPaths[g]) continue;
    const gp=new Path2D();
    for(let j=0;j<panelGroup.length;j++)
      if(panelGroup[j]===g)
        gp.addPath(curvedPath(j%cols,Math.floor(j/cols)));
    panelPaths[g]=gp;
  }
}

/* ===== 描画 ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width,canvas.height);
  if(mode==="play") buildPaths();

  for(const g in panelPaths){
    if(!groupVisible[g]) continue;
    const path=(mode==="play")?panelPaths[g]:panelPaths[g]||panelPaths[g];
    ctx.fillStyle=panelColor.value;
    ctx.fill(path);
    ctx.strokeStyle=lineColor.value;
    ctx.stroke(path);

    drawGroupText(g,path);
  }
}

/* ===== 文字（重心） ===== */
function drawGroupText(g,path){
  const d=groupData[g];
  const box=path.getBounds?.()||{x:canvas.width/2,y:canvas.height/2};
  ctx.fillStyle=d.color;
  ctx.textAlign="center";ctx.textBaseline="middle";
  ctx.font=`${d.size}px sans-serif`;
  ctx.fillText(d.name,box.x||canvas.width/2,box.y||canvas.height/2);
  ctx.font=`${d.size*0.8}px sans-serif`;
  ctx.fillText(d.cond,box.x||canvas.width/2,(box.y||canvas.height/2)+d.size);
}

/* ===== プレビュー ===== */
previewBtn.onclick=()=>{
  buildPaths();
  pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  pctx.drawImage(img,0,0,previewCanvas.width,previewCanvas.height);
  for(const g in panelPaths)
    if(groupVisible[g]){
      pctx.fillStyle=panelColor.value;
      pctx.fill(panelPaths[g]);
    }
  previewWrap.style.display="flex";
};

/* ===== 操作 ===== */
canvas.onpointerdown=e=>{
  const r=canvas.getBoundingClientRect();
  const px=(e.clientX-r.left)*(canvas.width/r.width);
  const py=(e.clientY-r.top)*(canvas.height/r.height);
  const x=Math.floor(px/(canvas.width/cols));
  const y=Math.floor(py/(canvas.height/rows));
  const i=y*cols+x;

  if(mode==="edit" && mergeMode){
    selected.has(i)?selected.delete(i):selected.add(i);
    draw();return;
  }
};

panelBuild.onclick=()=>{mode="play";draw();}
panelEdit.onclick=()=>{mode="edit";for(const g in groupVisible)groupVisible[g]=true;draw();}
</script>
</body>
</html>
