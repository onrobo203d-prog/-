<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Panel Reveal - 自動パネル化</title>
<style>
body{
  margin:0;
  font-family:sans-serif;
  background:#f4f4f4;
  text-align:center;
}
.controls{
  margin:15px;
}
#canvasArea{
  display:flex;
  justify-content:center;
  align-items:center;
  padding:60px 0;
}
canvas{
  max-width:90vw;
  height:auto;
  background:#999;
  box-shadow:0 0 10px rgba(0,0,0,0.2);
  touch-action:none;
}
button{
  margin:5px;
  padding:6px 12px;
}
input[type=color]{
  height:30px;
}
</style>
</head>
<body>

<h2>Panel Reveal Builder - 自動パネル化版</h2>

<div class="controls">
<input type="file" id="upload">
壁色 <input type="color" id="wallColor" value="#000000">
線太さ <input type="range" id="lineWidth" min="2" max="30" value="8">
<button id="splitBtn">パネル分割</button>
<button id="resetBtn">リセット</button>
</div>

<div class="controls">
<button id="modeBtn">編集</button>
<button id="previewBtn">プレビュー出力</button>
</div>

<div id="canvasArea">
<canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let image = new Image();
let lines = [];
let panels = [];
let drawing = false;
let mode = "edit";

let canvasW = 0;
let canvasH = 0;
const MAX_EDIT_SIZE = 800;
const CLOSE_DIST = 10; // 線端同士を接続判定する距離

/* ============================= */
/* 画像読み込み */
document.getElementById("upload").onchange = e => {
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = ev => { image.src = ev.target.result; };
  reader.readAsDataURL(file);
};

image.onload = () => {
  const ratio = Math.min(MAX_EDIT_SIZE/image.width, MAX_EDIT_SIZE/image.height);
  canvasW = image.width * ratio;
  canvasH = image.height * ratio;

  canvas.width = canvasW;
  canvas.height = canvasH;

  lines = [];
  panels = [];
  drawAll();
};

/* ============================= */
/* 描画 */
function drawAll(){
  ctx.clearRect(0,0,canvasW,canvasH);
  ctx.drawImage(image,0,0,canvasW,canvasH);

  // 線描画
  lines.forEach(line => {
    ctx.strokeStyle = line.color;
    ctx.lineWidth = line.width;
    ctx.beginPath();
    ctx.moveTo(line.points[0].x,line.points[0].y);
    for(let i=1;i<line.points.length;i++){
      ctx.lineTo(line.points[i].x,line.points[i].y);
    }
    ctx.stroke();
  });

  // パネル描画
  panels.forEach(p => {
    if(mode==="edit" || !p.unlocked){
      ctx.fillStyle = p.color;
      ctx.fill(p.path);
    }
  });
}

/* ============================= */
/* 座標補正 */
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  return { x:(e.clientX-rect.left)*(canvas.width/rect.width),
           y:(e.clientY-rect.top)*(canvas.height/rect.height) };
}

/* ============================= */
/* 線描画 */
canvas.addEventListener("pointerdown", e => {
  if(mode!=="edit") return;
  drawing = true;
  const pos = getPos(e);
  lines.push({
    color: document.getElementById("wallColor").value,
    width: parseInt(document.getElementById("lineWidth").value),
    points: [pos]
  });
});
canvas.addEventListener("pointermove", e => {
  if(!drawing) return;
  const pos = getPos(e);
  lines[lines.length-1].points.push(pos);
  drawAll();
});
canvas.addEventListener("pointerup", ()=>drawing=false);

/* ============================= */
/* パネル解放クリック */
canvas.addEventListener("click", e => {
  if(mode!=="play") return;
  const pos = getPos(e);
  panels.forEach(p => {
    if(ctx.isPointInPath(p.path,pos.x,pos.y)){
      p.unlocked = !p.unlocked;
    }
  });
  drawAll();
});

/* ============================= */
/* パネル分割 - 自動閉じ領域検出 */
document.getElementById("splitBtn").onclick = () => {
  if(!image.src) return;
  panels = [];

  // 1. 画像全体を初期パネルとして作成
  const initialPath = new Path2D();
  initialPath.rect(0,0,canvasW,canvasH);
  panels.push({ path: initialPath, color:"#ffffff", unlocked:false });

  // 2. 線から閉じた輪郭を自動検出してパネル化
  // 簡易版：線端同士が近い場合に輪郭とみなし Path2D に変換
  const used = new Set();

  for(let i=0;i<lines.length;i++){
    if(used.has(i)) continue;
    const line = lines[i];
    let contour = [...line.points];
    used.add(i);

    // 他の線端と接続されていれば輪郭を延長
    let changed = true;
    while(changed){
      changed = false;
      for(let j=0;j<lines.length;j++){
        if(used.has(j)) continue;
        const l2 = lines[j];
        const d1 = distance(contour[0], l2.points[0]);
        const d2 = distance(contour[0], l2.points[l2.points.length-1]);
        const d3 = distance(contour[contour.length-1], l2.points[0]);
        const d4 = distance(contour[contour.length-1], l2.points[l2.points.length-1]);
        const minD = Math.min(d1,d2,d3,d4);
        if(minD < CLOSE_DIST){
          // 接続
          if(minD===d1) contour = [...l2.points.reverse(), ...contour];
          else if(minD===d2) contour = [...l2.points, ...contour];
          else if(minD===d3) contour = [...contour, ...l2.points];
          else contour = [...contour, ...l2.points.reverse()];
          used.add(j);
          changed = true;
        }
      }
    }

    // 閉じていれば Path2D に変換してパネル化
    if(distance(contour[0], contour[contour.length-1])<CLOSE_DIST || touchesEdge(contour)){
      const path = new Path2D();
      path.moveTo(contour[0].x, contour[0].y);
      for(let k=1;k<contour.length;k++) path.lineTo(contour[k].x, contour[k].y);
      path.closePath();
      panels.push({ path:path, color:"#ffffff", unlocked:false });
    }
  }

  drawAll();
};

/* ============================= */
/* リセット */
document.getElementById("resetBtn").onclick = () => { lines=[]; panels=[]; drawAll(); };

/* ============================= */
/* モード切替 */
document.getElementById("modeBtn").onclick = function(){
  if(mode==="edit"){ mode="play"; this.textContent="編集"; }
  else{ mode="edit"; this.textContent="保存"; }
  drawAll();
};

/* ============================= */
/* プレビュー出力 */
document.getElementById("previewBtn").onclick = () => {
  if(!image.src) return;
  const max=1080;
  const ratio=Math.min(max/image.width,max/image.height);
  const outW=image.width*ratio;
  const outH=image.height*ratio;
  const out=document.createElement("canvas");
  out.width=outW;
  out.height=outH;
  const octx=out.getContext("2d");

  octx.drawImage(image,0,0,outW,outH);

  panels.forEach(p=>{
    if(!p.unlocked){
      const scaleX=outW/canvasW;
      const scaleY=outH/canvasH;
      octx.save();
      octx.scale(scaleX,scaleY);
      octx.fillStyle=p.color;
      octx.fill(p.path);
      octx.restore();
    }
  });

  const win=window.open();
  win.document.body.appendChild(out);
};

/* ============================= */
/* ヘルパー */
function distance(p1,p2){ return Math.hypot(p1.x-p2.x,p1.y-p2.y); }
function touchesEdge(points){
  return points.some(p => p.x<=0 || p.y<=0 || p.x>=canvasW || p.y>=canvasH);
}
</script>

</body>
</html>
