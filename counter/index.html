<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>パネル開けエディタ</title>

<style>
body{margin:0;font-family:sans-serif;background:#f4f4f4;text-align:center;}
#topbar{padding:10px;background:#222;color:#fff;}
button,input{margin:4px;}
#canvasWrapper{width:100%;display:flex;justify-content:center;}
canvas{
 max-width:100vw;
 max-height:80vh;
 height:auto;
 width:auto;
 border:1px solid #999;
 touch-action:none;
}
.modal{
 position:fixed;inset:0;background:rgba(0,0,0,.6);
 display:flex;align-items:center;justify-content:center;
}
.modalContent{
 background:#fff;padding:20px;border-radius:10px;
}
.hidden{display:none;}
#panelEditor{
 position:fixed;right:0;top:0;background:#fff;
 padding:10px;border-left:2px solid #ccc;
 display:none;
}
</style>
</head>
<body>

<div id="topbar">
<input type="file" id="imageLoader" accept="image/*">
<label>線の太さ</label>
<input type="range" id="lineWidth" min="1" max="20" value="3">
<button id="toggleSplitMode">分割モード</button>
<button id="splitBtn">パネル分割</button>
<button id="undoBtn">戻る</button>
<button id="previewBtn">進捗</button>
<button id="exportBtn">外部保存</button>
<button id="importBtn">読み込み</button>
<input type="file" id="importFile" accept=".json" hidden>
</div>

<div id="canvasWrapper">
<canvas id="canvas"></canvas>
</div>

<!-- 起動モーダル -->
<div id="startupModal" class="modal hidden">
 <div class="modalContent">
  <h3>前回データがあります</h3>
  <button id="restoreBtn">復旧</button>
  <button id="newBtn">新規作成</button>
  <button id="importStartupBtn">外部読込</button>
 </div>
</div>

<!-- パネル編集UI -->
<div id="panelEditor">
<h3>パネル編集</h3>
<label>名前</label><br>
<input type="text" id="panelName"><br>
<label>パネル色</label><br>
<input type="color" id="panelColor"><br>
<label>文字色</label><br>
<input type="color" id="textColor"><br>
<button id="closeEditor">閉じる</button>
</div>

<script>
const STORAGE_KEY="panelPuzzleSave_v3";

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const image=new Image();

let panels=[];
let drawLines=[];
let currentLine=[];
let drawing=false;
let splitMode=false;
let selectedPanel=null;

function getScaledPos(evt){
 const rect=canvas.getBoundingClientRect();
 const scaleX=canvas.width/rect.width;
 const scaleY=canvas.height/rect.height;
 return{
  x:(evt.clientX-rect.left)*scaleX,
  y:(evt.clientY-rect.top)*scaleY
 };
}

function resizeCanvas(){
 canvas.width=image.width;
 canvas.height=image.height;
 redraw();
}

function createPath(points){
 const path=new Path2D();
 path.moveTo(points[0].x,points[0].y);
 points.forEach(pt=>path.lineTo(pt.x,pt.y));
 path.closePath();
 return path;
}

function redraw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 if(image.src) ctx.drawImage(image,0,0);

 panels.forEach(p=>{
  if(!p.unlocked){
   ctx.fillStyle=p.color;
   ctx.fill(p.path);

   ctx.fillStyle=p.textColor;
   ctx.font="16px sans-serif";
   ctx.textAlign="center";
   const c=p.points[0];
   ctx.fillText(p.name,c.x,c.y);
  }
 });

 ctx.strokeStyle="red";
 ctx.lineWidth=document.getElementById("lineWidth").value;

 drawLines.forEach(line=>{
  ctx.beginPath();
  ctx.moveTo(line[0].x,line[0].y);
  line.forEach(pt=>ctx.lineTo(pt.x,pt.y));
  ctx.stroke();
 });

 if(currentLine.length>1){
  ctx.beginPath();
  ctx.moveTo(currentLine[0].x,currentLine[0].y);
  currentLine.forEach(pt=>ctx.lineTo(pt.x,pt.y));
  ctx.stroke();
 }
}

canvas.addEventListener("pointerdown",e=>{
 if(!splitMode) return;
 drawing=true;
 currentLine=[getScaledPos(e)];
});

canvas.addEventListener("pointermove",e=>{
 if(!drawing || !splitMode) return;
 currentLine.push(getScaledPos(e));
 redraw();
});

canvas.addEventListener("pointerup",()=>{
 if(!drawing || !splitMode) return;
 drawing=false;
 if(currentLine.length>2){
  drawLines.push(currentLine);
 }
 currentLine=[];
 redraw();
});

canvas.addEventListener("click",e=>{
 const pos=getScaledPos(e);

 panels.forEach(p=>{
  if(ctx.isPointInPath(p.path,pos.x,pos.y)){
   selectedPanel=p;
   p.unlocked=!p.unlocked;
   openEditor(p);
   saveToStorage();
  }
 });

 redraw();
});

function openEditor(panel){
 document.getElementById("panelEditor").style.display="block";
 document.getElementById("panelName").value=panel.name;
 document.getElementById("panelColor").value=panel.color;
 document.getElementById("textColor").value=panel.textColor;
}

document.getElementById("panelName").oninput=e=>{
 if(!selectedPanel) return;
 selectedPanel.name=e.target.value;
 saveToStorage();
 redraw();
};

document.getElementById("panelColor").oninput=e=>{
 if(!selectedPanel) return;
 selectedPanel.color=e.target.value;
 saveToStorage();
 redraw();
};

document.getElementById("textColor").oninput=e=>{
 if(!selectedPanel) return;
 selectedPanel.textColor=e.target.value;
 saveToStorage();
 redraw();
};

document.getElementById("closeEditor").onclick=()=>{
 document.getElementById("panelEditor").style.display="none";
};

document.getElementById("splitBtn").onclick=()=>{
 drawLines.forEach(line=>{
  const panel={
   id:Date.now()+Math.random(),
   name:"パネル",
   condition:"",
   color:"#000000",
   textColor:"#ffffff",
   unlocked:false,
   points:line,
   path:createPath(line)
  };
  panels.push(panel);
 });
 drawLines=[];
 splitMode=false;
 saveToStorage();
 redraw();
};

document.getElementById("toggleSplitMode").onclick=()=>{
 splitMode=!splitMode;
};

document.getElementById("undoBtn").onclick=()=>{
 panels.pop();
 saveToStorage();
 redraw();
};

document.getElementById("previewBtn").onclick=()=>{
 const u=panels.filter(p=>p.unlocked).length;
 alert(`進捗 ${u}/${panels.length}`);
};

document.getElementById("imageLoader").addEventListener("change",function(){
 const reader=new FileReader();
 reader.onload=e=>{ image.src=e.target.result; };
 reader.readAsDataURL(this.files[0]);
});

image.onload=()=>{
 resizeCanvas();
 saveToStorage();
};

function saveToStorage(){
 const data={
  image:image.src,
  panels:panels.map(p=>({...p,path:null}))
 };
 localStorage.setItem(STORAGE_KEY,JSON.stringify(data));
}

function loadFromStorage(){
 const saved=JSON.parse(localStorage.getItem(STORAGE_KEY));
 if(!saved) return;
 image.src=saved.image;
 panels=saved.panels.map(p=>({...p,path:createPath(p.points)}));
}

document.getElementById("exportBtn").onclick=()=>{
 const blob=new Blob(
  [localStorage.getItem(STORAGE_KEY)],
  {type:"application/json"}
 );
 const url=URL.createObjectURL(blob);
 const a=document.createElement("a");
 a.href=url;
 a.download="panelSave.json";
 a.click();
 URL.revokeObjectURL(url);
};

document.getElementById("importBtn").onclick=()=>{
 document.getElementById("importFile").click();
};

document.getElementById("importStartupBtn").onclick=()=>{
 document.getElementById("importFile").click();
};

document.getElementById("importFile").addEventListener("change",function(){
 const reader=new FileReader();
 reader.onload=e=>{
  localStorage.setItem(STORAGE_KEY,e.target.result);
  location.reload();
 };
 reader.readAsText(this.files[0]);
});

document.getElementById("restoreBtn").onclick=()=>{
 document.getElementById("startupModal").classList.add("hidden");
 loadFromStorage();
};

document.getElementById("newBtn").onclick=()=>{
 localStorage.removeItem(STORAGE_KEY);
 location.reload();
};

window.onload=()=>{
 if(localStorage.getItem(STORAGE_KEY)){
  document.getElementById("startupModal").classList.remove("hidden");
 }
};
</script>

</body>
</html>
