<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Panel Mask – Merge Button Mode</title>
<style>
body{margin:0;font-family:sans-serif;background:#f2f2f2}
.controls{text-align:center;padding:8px}
canvas{display:block;margin:auto;max-width:95vw;background:#aaa;touch-action:none}
button,input,textarea{margin:4px}
.panel-ui{background:#fff;border:1px solid #ccc;margin:6px;padding:6px}
.panel-ui input,.panel-ui textarea{width:95%}
</style>
</head>
<body>

<div class="controls">
<input type="file" id="upload"><br>

横 <input type="number" id="cols" value="4">
縦 <input type="number" id="rows" value="4">
合計 <span id="total">16</span><br>

<button id="panelBuild">パネル生成</button>
<button id="panelEdit">パネル編集</button>
<button id="mergeBtn">パネル合体</button><br>

パネル色 <input type="color" id="panelColor" value="#000000">
枠線色 <input type="color" id="lineColor" value="#00ffff">
</div>

<canvas id="canvas"></canvas>
<div id="panelTexts"></div>

<script>
/* ===== DOM ===== */
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const upload=document.getElementById("upload");
const colsInput=document.getElementById("cols");
const rowsInput=document.getElementById("rows");
const total=document.getElementById("total");
const panelBuild=document.getElementById("panelBuild");
const panelEdit=document.getElementById("panelEdit");
const mergeBtn=document.getElementById("mergeBtn");
const panelColor=document.getElementById("panelColor");
const lineColor=document.getElementById("lineColor");
const panelTexts=document.getElementById("panelTexts");

/* ===== 状態 ===== */
let img=new Image();
let cols=4,rows=4;
let mode="edit";           // edit / play
let mergeMode=false;       // パネル選択モード
let selectedPanels=new Set();

let hLines=[],vLines=[];
let mergedEdges={};

let panelVisible=[],panelData=[],panelPaths=[];
let drag=null;

const MAX=900,HIT=12;

/* ===== 数値 ===== */
colsInput.oninput=rowsInput.oninput=()=>{
  total.textContent=colsInput.value*rowsInput.value;
};

/* ===== 画像 ===== */
upload.onchange=e=>{
  const r=new FileReader();
  r.onload=ev=>img.src=ev.target.result;
  r.readAsDataURL(e.target.files[0]);
};
img.onload=()=>{
  const s=Math.min(MAX/img.width,MAX/img.height);
  canvas.width=img.width*s;
  canvas.height=img.height*s;
  initGrid();
};

/* ===== 初期化 ===== */
function initGrid(){
  cols=+colsInput.value;
  rows=+rowsInput.value;
  total.textContent=cols*rows;

  hLines=[];vLines=[];
  mergedEdges={};
  panelVisible=[];panelData=[];panelPaths=[];
  panelTexts.innerHTML="";
  selectedPanels.clear();
  mergeMode=false;
  mergeBtn.textContent="パネル合体";

  for(let y=0;y<=rows;y++){
    hLines[y]=[];
    for(let x=0;x<cols;x++) hLines[y][x]={dy:0};
  }
  for(let x=0;x<=cols;x++){
    vLines[x]=[];
    for(let y=0;y<rows;y++) vLines[x][y]={dx:0};
  }

  for(let i=0;i<cols*rows;i++){
    panelVisible[i]=true;
    panelData[i]={
      name:"",condition:"",
      textColor:"#fff",
      sizeName:14,sizeCond:12
    };
    createTextUI(i);
  }
  draw();
}

/* ===== UI ===== */
function createTextUI(i){
  const d=document.createElement("div");
  d.className="panel-ui";
  d.innerHTML=`
<b>パネル ${i+1}</b><br>
名称<br><input data-i="${i}" data-k="name"><br>
文字サイズ <input type="range" min="8" max="40" value="14" data-i="${i}" data-k="sizeName"><br>
条件<br><textarea rows="2" data-i="${i}" data-k="condition"></textarea><br>
文字サイズ <input type="range" min="8" max="40" value="12" data-i="${i}" data-k="sizeCond"><br>
文字色 <input type="color" value="#ffffff" data-i="${i}" data-k="textColor">
`;
  d.oninput=e=>{
    const p=panelData[e.target.dataset.i];
    p[e.target.dataset.k]=
      e.target.type==="range"?+e.target.value:e.target.value;
    draw();
  };
  panelTexts.appendChild(d);
}

/* ===== モード ===== */
panelBuild.onclick=()=>{
  mode="play";
  mergeMode=false;
  selectedPanels.clear();
  mergeBtn.textContent="パネル合体";
  panelPaths=[];
  for(let y=0;y<rows;y++)for(let x=0;x<cols;x++)
    panelPaths.push(makePanelPath(x,y));
  draw();
};

panelEdit.onclick=()=>{
  mode="edit";
  panelVisible.fill(true);
  selectedPanels.clear();
  mergeMode=false;
  mergeBtn.textContent="パネル合体";
  draw();
};

/* ===== 合体ボタン ===== */
mergeBtn.onclick=()=>{
  if(mode!=="edit") return;

  if(!mergeMode){
    mergeMode=true;
    selectedPanels.clear();
    mergeBtn.textContent="合体実行";
  }else{
    executeMerge();
    mergeMode=false;
    selectedPanels.clear();
    mergeBtn.textContent="パネル合体";
  }
  draw();
};

/* ===== 合体処理 ===== */
function executeMerge(){
  const indices=[...selectedPanels];
  if(indices.length<2) return;

  indices.forEach(i=>{
    const x=i%cols,y=Math.floor(i/cols);
    const neighbors=[
      {e:`v${x}-${y}`,j:i-1},
      {e:`v${x+1}-${y}`,j:i+1},
      {e:`h${y}-${x}`,j:i-cols},
      {e:`h${y+1}-${x}`,j:i+cols}
    ];
    neighbors.forEach(n=>{
      if(indices.includes(n.j)){
        mergedEdges[n.e]=true;
      }
    });
  });
}

/* ===== Path ===== */
function makePanelPath(x,y){
  const w=canvas.width/cols,h=canvas.height/rows;
  const x0=x*w,y0=y*h,x1=x0+w,y1=y0+h;
  const p=new Path2D();
  p.moveTo(x0,y0);

  if(!mergedEdges[`h${y}-${x}`])
    p.quadraticCurveTo(x0+w/2,y0+hLines[y][x].dy,x1,y0);
  else p.lineTo(x1,y0);

  if(!mergedEdges[`v${x+1}-${y}`])
    p.quadraticCurveTo(x1+vLines[x+1][y].dx,y0+h/2,x1,y1);
  else p.lineTo(x1,y1);

  if(!mergedEdges[`h${y+1}-${x}`])
    p.quadraticCurveTo(x0+w/2,y1+hLines[y+1][x].dy,x0,y1);
  else p.lineTo(x0,y1);

  if(!mergedEdges[`v${x}-${y}`])
    p.quadraticCurveTo(x0+vLines[x][y].dx,y0+h/2,x0,y0);
  else p.lineTo(x0,y0);

  p.closePath();
  return p;
}

/* ===== 描画 ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width,canvas.height);

  for(let y=0;y<rows;y++)for(let x=0;x<cols;x++){
    const i=y*cols+x;
    if(!panelVisible[i]) continue;
    const path=mode==="play"?panelPaths[i]:makePanelPath(x,y);

    ctx.fillStyle=panelColor.value;
    ctx.fill(path);

    ctx.strokeStyle=lineColor.value;
    ctx.stroke(path);

    if(mergeMode && selectedPanels.has(i)){
      ctx.fillStyle="rgba(255,255,0,0.35)";
      ctx.fill(path);
    }
    drawText(i,x,y);
  }
}

function drawText(i,x,y){
  const d=panelData[i];
  const w=canvas.width/cols,h=canvas.height/rows;
  ctx.fillStyle=d.textColor;
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.font=`${d.sizeName}px sans-serif`;
  ctx.fillText(d.name,x*w+w/2,y*h+h/2-10);
  ctx.font=`${d.sizeCond}px sans-serif`;
  ctx.fillText(d.condition,x*w+w/2,y*h+h/2+10);
}

/* ===== ポインタ ===== */
canvas.onpointerdown=e=>{
  const r=canvas.getBoundingClientRect();
  const px=(e.clientX-r.left)*(canvas.width/r.width);
  const py=(e.clientY-r.top)*(canvas.height/r.height);
  const w=canvas.width/cols,h=canvas.height/rows;
  const x=Math.floor(px/w),y=Math.floor(py/h);
  const i=y*cols+x;

  if(mode==="edit" && mergeMode){
    if(i>=0&&i<cols*rows){
      selectedPanels.has(i)?selectedPanels.delete(i):selectedPanels.add(i);
      draw();
    }
    return;
  }

  if(mode!=="edit") return;

  if(Math.abs(py-y*h)<HIT) drag={t:"h",x,y};
  else if(Math.abs(py-(y+1)*h)<HIT) drag={t:"h",x,y:y+1};
  else if(Math.abs(px-x*w)<HIT) drag={t:"v",x,y};
  else if(Math.abs(px-(x+1)*w)<HIT) drag={t:"v",x:x+1,y};
};

canvas.onpointermove=e=>{
  if(!drag) return;
  const r=canvas.getBoundingClientRect();
  const px=(e.clientX-r.left)*(canvas.width/r.width);
  const py=(e.clientY-r.top)*(canvas.height/r.height);
  if(drag.t==="h"){
    const base=drag.y*(canvas.height/rows);
    hLines[drag.y][drag.x].dy=py-base;
  }else{
    const base=drag.x*(canvas.width/cols);
    vLines[drag.x][drag.y].dx=px-base;
  }
  draw();
};
canvas.onpointerup=()=>drag=null;

/* ===== 再生 ===== */
canvas.onclick=e=>{
  if(mode!=="play") return;
  const r=canvas.getBoundingClientRect();
  const px=(e.clientX-r.left)*(canvas.width/r.width);
  const py=(e.clientY-r.top)*(canvas.height/r.height);
  panelPaths.forEach((p,i)=>{
    if(panelVisible[i]&&ctx.isPointInPath(p,px,py)){
      panelVisible[i]=false;
      draw();
    }
  });
};
</script>
</body>
</html>
