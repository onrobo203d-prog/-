<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>パネル解放ツール</title>
<style>
body { font-family: sans-serif; margin:0; background:#f5f5f5; text-align:center; }
.controls { padding:10px; background:white; position:sticky; top:0; z-index:10; }
canvas { background:#ddd; max-width:95vw; margin:10px auto; display:block; touch-action:manipulation; }
button, input { margin:3px; padding:6px; }
.status { margin:5px; font-weight:bold; }
</style>
</head>
<body>

<div class="controls">
<input type="file" id="imageUpload" accept="image/*">
<br>
横 <input type="number" id="gridX" value="5" min="1" style="width:60px;">
縦 <input type="number" id="gridY" value="5" min="1" style="width:60px;">
パネル色 <input type="color" id="panelColor" value="#000000">
文字色 <input type="color" id="textColor" value="#ffffff">
<button id="generateBtn">パネル生成</button>
<br>
<button id="editToggle">編集</button>
<button id="undoBtn">戻る</button>
<button id="unlockAllBtn">全解放</button>
<button id="exportBtn">画像出力</button>
</div>

<canvas id="canvas" width="1080" height="1080"></canvas>
<div class="status" id="progressText"></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let appState = {
  image: null,
  panels: [],
  history: []
};

let editMode = false;

function saveState() {
  localStorage.setItem("panelAppData", JSON.stringify(appState));
}

function loadState() {
  const data = localStorage.getItem("panelAppData");
  if (data) {
    if (confirm("前回のデータを復元しますか？")) {
      appState = JSON.parse(data);
      redraw();
    } else {
      localStorage.removeItem("panelAppData");
    }
  }
}

function pushHistory() {
  appState.history.push(JSON.stringify(appState.panels));
  if (appState.history.length > 50) appState.history.shift();
}

function undo() {
  if (appState.history.length === 0) return;
  const prev = appState.history.pop();
  appState.panels = JSON.parse(prev);
  redraw();
  saveState();
}

function resizeTo1080(img) {
  const temp = document.createElement("canvas");
  temp.width = 1080;
  temp.height = 1080;
  const tctx = temp.getContext("2d");
  tctx.drawImage(img, 0, 0, 1080, 1080);
  return temp.toDataURL("image/png");
}

document.getElementById("imageUpload").addEventListener("change", e => {
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = function(evt) {
    const img = new Image();
    img.onload = function() {
      appState.image = resizeTo1080(img);
      appState.panels = [];
      pushHistory();
      redraw();
      saveState();
    }
    img.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById("generateBtn").addEventListener("click", () => {
  if (!appState.image) return alert("画像をアップロードしてください");
  pushHistory();
  const gx = parseInt(document.getElementById("gridX").value);
  const gy = parseInt(document.getElementById("gridY").value);
  const color = document.getElementById("panelColor").value;
  appState.panels = [];
  const w = 1080 / gx;
  const h = 1080 / gy;
  for (let y=0;y<gy;y++){
    for (let x=0;x<gx;x++){
      appState.panels.push({
        x:x*w, y:y*h, w:w, h:h,
        color:color,
        text:"",
        textColor: document.getElementById("textColor").value,
        hidden:false
      });
    }
  }
  redraw();
  saveState();
});

document.getElementById("editToggle").addEventListener("click", ()=>{
  editMode = !editMode;
  document.getElementById("editToggle").innerText = editMode ? "保存" : "編集";
});

document.getElementById("undoBtn").addEventListener("click", undo);

document.getElementById("unlockAllBtn").addEventListener("click", ()=>{
  pushHistory();
  appState.panels.forEach(p=>p.hidden=true);
  redraw();
  saveState();
});

document.getElementById("exportBtn").addEventListener("click", ()=>{
  const link = document.createElement("a");
  link.download = "progress.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
});

canvas.addEventListener("click", e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (1080 / rect.width);
  const y = (e.clientY - rect.top) * (1080 / rect.height);

  for (let p of appState.panels){
    if (x>=p.x && x<=p.x+p.w && y>=p.y && y<=p.y+p.h){
      pushHistory();
      if (editMode){
        const text = prompt("パネル文字を入力", p.text);
        if (text !== null) {
          p.text = text;
          p.textColor = document.getElementById("textColor").value;
        }
      } else {
        p.hidden = true;
      }
      redraw();
      saveState();
      break;
    }
  }
});

function redraw(){
  if (!appState.image) return;
  const img = new Image();
  img.onload = function(){
    ctx.clearRect(0,0,1080,1080);
    ctx.drawImage(img,0,0);
    let openCount=0;
    for (let p of appState.panels){
      if (!p.hidden){
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x,p.y,p.w,p.h);
        ctx.strokeStyle="#ffffff";
        ctx.strokeRect(p.x,p.y,p.w,p.h);
        if (p.text){
          ctx.fillStyle = p.textColor;
          ctx.font = "bold 30px sans-serif";
          ctx.textAlign="center";
          ctx.textBaseline="middle";
          ctx.fillText(p.text, p.x+p.w/2, p.y+p.h/2, p.w-10);
        }
      } else {
        openCount++;
      }
    }
    document.getElementById("progressText").innerText =
      openCount + " / " + appState.panels.length + " 解放";
  }
  img.src = appState.image;
}

loadState();
</script>

</body>
</html>
